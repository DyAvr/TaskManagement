# Task Management Pet Project

Этот репозиторий содержит pet-проект, в котором реализуется система управления задачами, включая работу с подзадачами, комментариями и простым Rate Limiter’ом. Ниже описаны все основные возможности, а также информация о подготовке окружения и структуре базы данных.

---

## Содержание

1. [Подготовка окружения](#подготовка-окружения)
2. [Описание базы данных](#описание-базы-данных)
3. [Основные возможности и требования](#основные-возможности-и-требования)
    - [Проверка подзадач для завершаемой задачи](#проверка-подзадач-для-завершаемой-задачи)
    - [Операции над комментариями к задаче](#операции-над-комментариями-к-задаче)
    - [RateLimiter на основе Redis](#ratelimiter-на-основе-redis)
4. [Тестирование](#тестирование)
5. [Как запустить](#как-запустить)

---

## Подготовка окружения

Перед началом работы рекомендуется настроить окружение в соответствии с инструкциями из [документа](./docs/01-prepare-environment.md).  
Это позволит корректно запустить проект, базу данных и обеспечит полноценную работу всех сервисов.

---

## Описание базы данных

Полное описание базы данных, включая схему и описание полей, доступно по ссылке: [03-db-description.md](./docs/03-db-description.md).  
Настоятельно рекомендуется ознакомиться с этим документом перед запуском проекта, чтобы понимать, как хранится информация о задачах, комментариях и связанные с ними поля.

---

## Основные возможности и требования

Проект состоит из нескольких сервисов, каждый из которых отвечает за свою часть функциональности. Для упрощения поддержания кода **нет** избыточных рефакторингов и новых уровней абстракции — кодовая база в отдельных сервисах взаимосвязана минимальным набором паттернов.

### Общие замечания
- Все методы, работающие с базой данных, покрыты интеграционными тестами (см. [Тестирование](#тестирование)).
- Интеграционные тесты проверяют корректность SQL-запросов и маппинга результатов.
- Все даты хранятся в формате `DateTimeOffset` или `timestamp with time zone` в UTC.

---

### Проверка подзадач для завершаемой задачи

При работе с системой есть возможность иерархического построения задач и подзадач. Требуется метод, который:

1. Рекурсивно обходит все дочерние задачи (подзадачи).
2. Возвращает только те из них, что находятся в указанных статусах.
3. Формирует ответ, содержащий:
    - Идентификатор подзадачи,
    - Заголовок,
    - Текущий статус,
    - Путь от родительской задачи до текущей подзадачи (в виде массива `ParentTaskIds`).

#### Пример интерфейса репозитория

```
public interface ITaskRepository
{
    Task<SubTaskModel[]> GetSubTasksInStatus(long parentTaskId, TaskStatus[] statuses, CancellationToken token);
}

public record SubTaskModel
{
    public required long TaskId { get; init; }
    public required string Title { get; init; }
    public required TaskStatus Status { get; init; }
    public required long[] ParentTaskIds { get; init; }
}
```

> **Применение**:  
> Функциональность проверки статусов подзадач полезна, например, при завершении основной задачи. Логика требует, чтобы перед переводом задачи в статус `Done` все её дочерние задачи были `Done` или `Canceled`. Аналогично, если мы переводим задачу в `Canceled`, тогда все подзадачи также должны быть `Canceled`.

**Важные моменты**:
- При интеграционном тестировании полезно создавать иерархические структуры задач, чтобы убедиться в корректной работе рекурсивного обхода.
- Нужно проверить правильный порядок в `ParentTaskIds` (от родителя к дочерней задаче).
- Исходная (передаваемая как `parentTaskId`) задача не должна включаться в результирующий список подзадач.

---

### Операции над комментариями к задаче

Для таблицы `task_comments` были добавлены новые поля (через миграции):
- `modified_at timestamp with time zone null` – заполняется только при изменении сообщения.
- `deleted_at timestamp with time zone null` – заполняется только при удалении сообщения.

#### Функциональность в репозитории

```
public interface ITaskCommentRepository
{
    Task<long> Add(TaskCommentEntityV1 model, CancellationToken token);
    Task Update(TaskCommentEntityV1 model, CancellationToken token);
    Task SetDeleted(long taskId, CancellationToken token);
    Task<TaskCommentEntityV1[]> Get(TaskCommentGetModel model, CancellationToken token);
}

public record TaskCommentGetModel
{
    public required long TaskId { get; init; }
    public required bool IncludeDeleted { get; init; }
}
```

1. **Получение сообщений по задаче** с возможностью фильтра включения удалённых комментариев (по умолчанию удалённые не возвращаются).
    - Сортировка — от самого нового к более старым.

2. **Добавление нового сообщения**.
    - При создании заполняются дата создания, текст сообщения и идентификатор задачи.

3. **Изменение сообщения**.
    - При обновлении устанавливается `modified_at = текущая дата UTC`, чтобы отследить факт изменения.

4. **Отметка сообщения как удалённого**.
    - Устанавливает `deleted_at = текущая дата UTC`.

#### Кэширование в сервисе (BLL-слой)

В `TaskService` предусмотрен метод для получения сообщений, который использует Redis-кэш. Кэш хранит последние 5 сообщений (самые новые), время жизни кэша — 5 секунд.

```
public interface ITaskService
{
    Task<TaskMessage[]> GetComments(long taskId, CancellationToken token);
}

public record TaskMessage
{
    public required long TaskId { get; init; }
    public required string Comment { get; init; }
    public required bool IsDeleted { get; init; }
    public required DateTimeOffset At { get; init; }
}
```

> **Примечание**:  
> При формировании даты для `modified_at` или `deleted_at` используется логика на уровне BLL. В SQL-запросах `now()` не применяется, чтобы можно было более гибко управлять значениями при тестировании.

---

### RateLimiter на основе Redis

Добавлена логика ограничения пропускной способности (Rate Limiting) на **100 запросов в минуту** с учётом IP-адреса пользователя. Предполагается, что IP-адрес берётся из заголовка `X-R256-USER-IP`.

**Основная идея**:
- Есть сервис `RateLimiterService`, работающий через Redis.
- Этот сервис вызывается до выполнения основного запроса (через Middleware или Interceptor).
- При превышении лимита возвращается ошибка и запрос не обрабатывается.

> Цель — реализовать простейший самодельный вариант рейт-лимитера с использованием Redis и закрепить навыки работы из C#. Никаких готовых решений (например, `redis-rate-limiting`) здесь не применяется.

---

## Тестирование

### Интеграционные тесты
- Проверяется корректность методов репозиториев (SQL-запросы, маппинг результатов).
- Тесты генерируют тестовые данные, включая иерархию задач и набор комментариев.
- Особое внимание уделено проверке полей `modified_at`, `deleted_at`, а также порядку родительских идентификаторов в методе получения подзадач.

### Юнит-тесты RateLimiter
- Тестируем стандартный сценарий без превышения лимита (успешное выполнение).
- Тестируем сценарий с превышением лимита (возвращается ошибка).

---

## Как запустить

1. **Поднять базу данных**:
    - Установить PostgreSQL и Redis (см. [документ](./docs/01-prepare-environment.md)).
    - Применить миграции, чтобы создать необходимые таблицы и поля.
2. **Сконфигурировать приложение**:
    - Настроить строки подключения в конфигурационных файлах.
    - Указать параметры Redis для кэширования и Rate Limiting’а.
3. **Запустить проект**:
    - `dotnet run` (или любым удобным способом из вашей IDE).

После успешного запуска вы можете проверять работу функциональности по указанным эндпоинтам (или в консольном приложении, если оно предусмотрено) и следить за логикой ограничений, комментариев и статусов подзадач.

---

## Контакты

Если у вас возникнут вопросы или вы захотите обсудить идею проекта — буду рад вашим PR, ишью и любому конструктивному фидбеку!

---

**Приятной разработки!**
